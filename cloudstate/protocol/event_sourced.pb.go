// Code generated by protoc-gen-go. DO NOT EDIT.
// source: cloudstate/event_sourced.proto

package protocol

import (
	context "context"
	fmt "fmt"
	math "math"

	proto "github.com/golang/protobuf/proto"
	any "github.com/golang/protobuf/ptypes/any"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

// The init message. This will always be the first message sent to the entity when
// it is loaded.
type EventSourcedInit struct {
	ServiceName string `protobuf:"bytes,1,opt,name=service_name,json=serviceName,proto3" json:"service_name,omitempty"`
	// The ID of the entity.
	EntityId string `protobuf:"bytes,2,opt,name=entity_id,json=entityId,proto3" json:"entity_id,omitempty"`
	// If present the entity should initialise its state using this snapshot.
	Snapshot             *EventSourcedSnapshot `protobuf:"bytes,3,opt,name=snapshot,proto3" json:"snapshot,omitempty"`
	XXX_NoUnkeyedLiteral struct{}              `json:"-"`
	XXX_unrecognized     []byte                `json:"-"`
	XXX_sizecache        int32                 `json:"-"`
}

func (m *EventSourcedInit) Reset()         { *m = EventSourcedInit{} }
func (m *EventSourcedInit) String() string { return proto.CompactTextString(m) }
func (*EventSourcedInit) ProtoMessage()    {}
func (*EventSourcedInit) Descriptor() ([]byte, []int) {
	return fileDescriptor_e62d03156a02a758, []int{0}
}

func (m *EventSourcedInit) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_EventSourcedInit.Unmarshal(m, b)
}
func (m *EventSourcedInit) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_EventSourcedInit.Marshal(b, m, deterministic)
}
func (m *EventSourcedInit) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventSourcedInit.Merge(m, src)
}
func (m *EventSourcedInit) XXX_Size() int {
	return xxx_messageInfo_EventSourcedInit.Size(m)
}
func (m *EventSourcedInit) XXX_DiscardUnknown() {
	xxx_messageInfo_EventSourcedInit.DiscardUnknown(m)
}

var xxx_messageInfo_EventSourcedInit proto.InternalMessageInfo

func (m *EventSourcedInit) GetServiceName() string {
	if m != nil {
		return m.ServiceName
	}
	return ""
}

func (m *EventSourcedInit) GetEntityId() string {
	if m != nil {
		return m.EntityId
	}
	return ""
}

func (m *EventSourcedInit) GetSnapshot() *EventSourcedSnapshot {
	if m != nil {
		return m.Snapshot
	}
	return nil
}

// A snapshot
type EventSourcedSnapshot struct {
	// The sequence number when the snapshot was taken.
	SnapshotSequence int64 `protobuf:"varint,1,opt,name=snapshot_sequence,json=snapshotSequence,proto3" json:"snapshot_sequence,omitempty"`
	// The snapshot.
	Snapshot             *any.Any `protobuf:"bytes,2,opt,name=snapshot,proto3" json:"snapshot,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *EventSourcedSnapshot) Reset()         { *m = EventSourcedSnapshot{} }
func (m *EventSourcedSnapshot) String() string { return proto.CompactTextString(m) }
func (*EventSourcedSnapshot) ProtoMessage()    {}
func (*EventSourcedSnapshot) Descriptor() ([]byte, []int) {
	return fileDescriptor_e62d03156a02a758, []int{1}
}

func (m *EventSourcedSnapshot) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_EventSourcedSnapshot.Unmarshal(m, b)
}
func (m *EventSourcedSnapshot) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_EventSourcedSnapshot.Marshal(b, m, deterministic)
}
func (m *EventSourcedSnapshot) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventSourcedSnapshot.Merge(m, src)
}
func (m *EventSourcedSnapshot) XXX_Size() int {
	return xxx_messageInfo_EventSourcedSnapshot.Size(m)
}
func (m *EventSourcedSnapshot) XXX_DiscardUnknown() {
	xxx_messageInfo_EventSourcedSnapshot.DiscardUnknown(m)
}

var xxx_messageInfo_EventSourcedSnapshot proto.InternalMessageInfo

func (m *EventSourcedSnapshot) GetSnapshotSequence() int64 {
	if m != nil {
		return m.SnapshotSequence
	}
	return 0
}

func (m *EventSourcedSnapshot) GetSnapshot() *any.Any {
	if m != nil {
		return m.Snapshot
	}
	return nil
}

// An event. These will be sent to the entity when the entity starts up.
type EventSourcedEvent struct {
	// The sequence number of the event.
	Sequence int64 `protobuf:"varint,1,opt,name=sequence,proto3" json:"sequence,omitempty"`
	// The event payload.
	Payload              *any.Any `protobuf:"bytes,2,opt,name=payload,proto3" json:"payload,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *EventSourcedEvent) Reset()         { *m = EventSourcedEvent{} }
func (m *EventSourcedEvent) String() string { return proto.CompactTextString(m) }
func (*EventSourcedEvent) ProtoMessage()    {}
func (*EventSourcedEvent) Descriptor() ([]byte, []int) {
	return fileDescriptor_e62d03156a02a758, []int{2}
}

func (m *EventSourcedEvent) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_EventSourcedEvent.Unmarshal(m, b)
}
func (m *EventSourcedEvent) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_EventSourcedEvent.Marshal(b, m, deterministic)
}
func (m *EventSourcedEvent) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventSourcedEvent.Merge(m, src)
}
func (m *EventSourcedEvent) XXX_Size() int {
	return xxx_messageInfo_EventSourcedEvent.Size(m)
}
func (m *EventSourcedEvent) XXX_DiscardUnknown() {
	xxx_messageInfo_EventSourcedEvent.DiscardUnknown(m)
}

var xxx_messageInfo_EventSourcedEvent proto.InternalMessageInfo

func (m *EventSourcedEvent) GetSequence() int64 {
	if m != nil {
		return m.Sequence
	}
	return 0
}

func (m *EventSourcedEvent) GetPayload() *any.Any {
	if m != nil {
		return m.Payload
	}
	return nil
}

// A reply to a command.
type EventSourcedReply struct {
	// The id of the command being replied to. Must match the input command.
	CommandId int64 `protobuf:"varint,1,opt,name=command_id,json=commandId,proto3" json:"command_id,omitempty"`
	// The action to take
	ClientAction *ClientAction `protobuf:"bytes,2,opt,name=client_action,json=clientAction,proto3" json:"client_action,omitempty"`
	// Any side effects to perform
	SideEffects []*SideEffect `protobuf:"bytes,3,rep,name=side_effects,json=sideEffects,proto3" json:"side_effects,omitempty"`
	// A list of events to persist - these will be persisted before the reply
	// is sent.
	Events []*any.Any `protobuf:"bytes,4,rep,name=events,proto3" json:"events,omitempty"`
	// An optional snapshot to persist. It is assumed that this snapshot will have
	// the state of any events in the events field applied to it. It is illegal to
	// send a snapshot without sending any events.
	Snapshot             *any.Any `protobuf:"bytes,5,opt,name=snapshot,proto3" json:"snapshot,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *EventSourcedReply) Reset()         { *m = EventSourcedReply{} }
func (m *EventSourcedReply) String() string { return proto.CompactTextString(m) }
func (*EventSourcedReply) ProtoMessage()    {}
func (*EventSourcedReply) Descriptor() ([]byte, []int) {
	return fileDescriptor_e62d03156a02a758, []int{3}
}

func (m *EventSourcedReply) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_EventSourcedReply.Unmarshal(m, b)
}
func (m *EventSourcedReply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_EventSourcedReply.Marshal(b, m, deterministic)
}
func (m *EventSourcedReply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventSourcedReply.Merge(m, src)
}
func (m *EventSourcedReply) XXX_Size() int {
	return xxx_messageInfo_EventSourcedReply.Size(m)
}
func (m *EventSourcedReply) XXX_DiscardUnknown() {
	xxx_messageInfo_EventSourcedReply.DiscardUnknown(m)
}

var xxx_messageInfo_EventSourcedReply proto.InternalMessageInfo

func (m *EventSourcedReply) GetCommandId() int64 {
	if m != nil {
		return m.CommandId
	}
	return 0
}

func (m *EventSourcedReply) GetClientAction() *ClientAction {
	if m != nil {
		return m.ClientAction
	}
	return nil
}

func (m *EventSourcedReply) GetSideEffects() []*SideEffect {
	if m != nil {
		return m.SideEffects
	}
	return nil
}

func (m *EventSourcedReply) GetEvents() []*any.Any {
	if m != nil {
		return m.Events
	}
	return nil
}

func (m *EventSourcedReply) GetSnapshot() *any.Any {
	if m != nil {
		return m.Snapshot
	}
	return nil
}

// Input message type for the gRPC stream in.
type EventSourcedStreamIn struct {
	// Types that are valid to be assigned to Message:
	//	*EventSourcedStreamIn_Init
	//	*EventSourcedStreamIn_Event
	//	*EventSourcedStreamIn_Command
	Message              isEventSourcedStreamIn_Message `protobuf_oneof:"message"`
	XXX_NoUnkeyedLiteral struct{}                       `json:"-"`
	XXX_unrecognized     []byte                         `json:"-"`
	XXX_sizecache        int32                          `json:"-"`
}

func (m *EventSourcedStreamIn) Reset()         { *m = EventSourcedStreamIn{} }
func (m *EventSourcedStreamIn) String() string { return proto.CompactTextString(m) }
func (*EventSourcedStreamIn) ProtoMessage()    {}
func (*EventSourcedStreamIn) Descriptor() ([]byte, []int) {
	return fileDescriptor_e62d03156a02a758, []int{4}
}

func (m *EventSourcedStreamIn) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_EventSourcedStreamIn.Unmarshal(m, b)
}
func (m *EventSourcedStreamIn) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_EventSourcedStreamIn.Marshal(b, m, deterministic)
}
func (m *EventSourcedStreamIn) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventSourcedStreamIn.Merge(m, src)
}
func (m *EventSourcedStreamIn) XXX_Size() int {
	return xxx_messageInfo_EventSourcedStreamIn.Size(m)
}
func (m *EventSourcedStreamIn) XXX_DiscardUnknown() {
	xxx_messageInfo_EventSourcedStreamIn.DiscardUnknown(m)
}

var xxx_messageInfo_EventSourcedStreamIn proto.InternalMessageInfo

type isEventSourcedStreamIn_Message interface {
	isEventSourcedStreamIn_Message()
}

type EventSourcedStreamIn_Init struct {
	Init *EventSourcedInit `protobuf:"bytes,1,opt,name=init,proto3,oneof"`
}

type EventSourcedStreamIn_Event struct {
	Event *EventSourcedEvent `protobuf:"bytes,2,opt,name=event,proto3,oneof"`
}

type EventSourcedStreamIn_Command struct {
	Command *Command `protobuf:"bytes,3,opt,name=command,proto3,oneof"`
}

func (*EventSourcedStreamIn_Init) isEventSourcedStreamIn_Message() {}

func (*EventSourcedStreamIn_Event) isEventSourcedStreamIn_Message() {}

func (*EventSourcedStreamIn_Command) isEventSourcedStreamIn_Message() {}

func (m *EventSourcedStreamIn) GetMessage() isEventSourcedStreamIn_Message {
	if m != nil {
		return m.Message
	}
	return nil
}

func (m *EventSourcedStreamIn) GetInit() *EventSourcedInit {
	if x, ok := m.GetMessage().(*EventSourcedStreamIn_Init); ok {
		return x.Init
	}
	return nil
}

func (m *EventSourcedStreamIn) GetEvent() *EventSourcedEvent {
	if x, ok := m.GetMessage().(*EventSourcedStreamIn_Event); ok {
		return x.Event
	}
	return nil
}

func (m *EventSourcedStreamIn) GetCommand() *Command {
	if x, ok := m.GetMessage().(*EventSourcedStreamIn_Command); ok {
		return x.Command
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*EventSourcedStreamIn) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*EventSourcedStreamIn_Init)(nil),
		(*EventSourcedStreamIn_Event)(nil),
		(*EventSourcedStreamIn_Command)(nil),
	}
}

// Output message type for the gRPC stream out.
type EventSourcedStreamOut struct {
	// Types that are valid to be assigned to Message:
	//	*EventSourcedStreamOut_Reply
	//	*EventSourcedStreamOut_Failure
	Message              isEventSourcedStreamOut_Message `protobuf_oneof:"message"`
	XXX_NoUnkeyedLiteral struct{}                        `json:"-"`
	XXX_unrecognized     []byte                          `json:"-"`
	XXX_sizecache        int32                           `json:"-"`
}

func (m *EventSourcedStreamOut) Reset()         { *m = EventSourcedStreamOut{} }
func (m *EventSourcedStreamOut) String() string { return proto.CompactTextString(m) }
func (*EventSourcedStreamOut) ProtoMessage()    {}
func (*EventSourcedStreamOut) Descriptor() ([]byte, []int) {
	return fileDescriptor_e62d03156a02a758, []int{5}
}

func (m *EventSourcedStreamOut) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_EventSourcedStreamOut.Unmarshal(m, b)
}
func (m *EventSourcedStreamOut) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_EventSourcedStreamOut.Marshal(b, m, deterministic)
}
func (m *EventSourcedStreamOut) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventSourcedStreamOut.Merge(m, src)
}
func (m *EventSourcedStreamOut) XXX_Size() int {
	return xxx_messageInfo_EventSourcedStreamOut.Size(m)
}
func (m *EventSourcedStreamOut) XXX_DiscardUnknown() {
	xxx_messageInfo_EventSourcedStreamOut.DiscardUnknown(m)
}

var xxx_messageInfo_EventSourcedStreamOut proto.InternalMessageInfo

type isEventSourcedStreamOut_Message interface {
	isEventSourcedStreamOut_Message()
}

type EventSourcedStreamOut_Reply struct {
	Reply *EventSourcedReply `protobuf:"bytes,1,opt,name=reply,proto3,oneof"`
}

type EventSourcedStreamOut_Failure struct {
	Failure *Failure `protobuf:"bytes,2,opt,name=failure,proto3,oneof"`
}

func (*EventSourcedStreamOut_Reply) isEventSourcedStreamOut_Message() {}

func (*EventSourcedStreamOut_Failure) isEventSourcedStreamOut_Message() {}

func (m *EventSourcedStreamOut) GetMessage() isEventSourcedStreamOut_Message {
	if m != nil {
		return m.Message
	}
	return nil
}

func (m *EventSourcedStreamOut) GetReply() *EventSourcedReply {
	if x, ok := m.GetMessage().(*EventSourcedStreamOut_Reply); ok {
		return x.Reply
	}
	return nil
}

func (m *EventSourcedStreamOut) GetFailure() *Failure {
	if x, ok := m.GetMessage().(*EventSourcedStreamOut_Failure); ok {
		return x.Failure
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*EventSourcedStreamOut) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*EventSourcedStreamOut_Reply)(nil),
		(*EventSourcedStreamOut_Failure)(nil),
	}
}

func init() {
	proto.RegisterType((*EventSourcedInit)(nil), "cloudstate.eventsourced.EventSourcedInit")
	proto.RegisterType((*EventSourcedSnapshot)(nil), "cloudstate.eventsourced.EventSourcedSnapshot")
	proto.RegisterType((*EventSourcedEvent)(nil), "cloudstate.eventsourced.EventSourcedEvent")
	proto.RegisterType((*EventSourcedReply)(nil), "cloudstate.eventsourced.EventSourcedReply")
	proto.RegisterType((*EventSourcedStreamIn)(nil), "cloudstate.eventsourced.EventSourcedStreamIn")
	proto.RegisterType((*EventSourcedStreamOut)(nil), "cloudstate.eventsourced.EventSourcedStreamOut")
}

func init() { proto.RegisterFile("cloudstate/event_sourced.proto", fileDescriptor_e62d03156a02a758) }

var fileDescriptor_e62d03156a02a758 = []byte{
	// 549 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x94, 0x54, 0xcd, 0x6e, 0xd3, 0x4c,
	0x14, 0x8d, 0x9b, 0x36, 0x3f, 0x37, 0xf9, 0xa4, 0x76, 0xda, 0xaf, 0x35, 0x41, 0xa0, 0x90, 0x55,
	0xf8, 0xa9, 0x53, 0x85, 0x15, 0x0b, 0x84, 0x1a, 0x54, 0x94, 0x6c, 0xa8, 0xe4, 0xec, 0xd8, 0x58,
	0x53, 0xfb, 0x26, 0x1d, 0xc9, 0x9e, 0x09, 0x9e, 0x71, 0xa5, 0x2c, 0x78, 0x03, 0xf6, 0xac, 0x78,
	0x2e, 0x5e, 0x07, 0x79, 0x66, 0x1c, 0x26, 0xa5, 0xa0, 0xb0, 0x1b, 0xcf, 0x39, 0xe7, 0xde, 0x33,
	0xe7, 0xde, 0x04, 0x9e, 0xc6, 0xa9, 0x28, 0x12, 0xa9, 0xa8, 0xc2, 0x11, 0xde, 0x21, 0x57, 0x91,
	0x14, 0x45, 0x1e, 0x63, 0x12, 0xac, 0x72, 0xa1, 0x04, 0x39, 0xfb, 0x85, 0x07, 0x1a, 0xb7, 0x70,
	0xef, 0xd1, 0x52, 0x88, 0x65, 0x8a, 0x23, 0x4d, 0xbb, 0x29, 0x16, 0x23, 0xca, 0xd7, 0x46, 0xd3,
	0x3b, 0x73, 0x6b, 0x72, 0xc5, 0x94, 0x05, 0x06, 0xdf, 0x3d, 0x38, 0xbc, 0x2a, 0x8b, 0xcc, 0x4d,
	0x91, 0x19, 0x67, 0x8a, 0x3c, 0x83, 0xae, 0xc4, 0xfc, 0x8e, 0xc5, 0x18, 0x71, 0x9a, 0xa1, 0xef,
	0xf5, 0xbd, 0x61, 0x3b, 0xec, 0xd8, 0xbb, 0x8f, 0x34, 0x43, 0xf2, 0x18, 0xda, 0xa6, 0x4e, 0xc4,
	0x12, 0x7f, 0x4f, 0xe3, 0x2d, 0x73, 0x31, 0x4b, 0xc8, 0x0c, 0x5a, 0x92, 0xd3, 0x95, 0xbc, 0x15,
	0xca, 0xaf, 0xf7, 0xbd, 0x61, 0x67, 0x7c, 0x1e, 0xfc, 0xc1, 0x74, 0xe0, 0x36, 0x9f, 0x5b, 0x51,
	0xb8, 0x91, 0x0f, 0x0a, 0x38, 0x79, 0x88, 0x41, 0x5e, 0xc2, 0x51, 0xc5, 0x89, 0x24, 0x7e, 0x2e,
	0x90, 0xc7, 0xc6, 0x67, 0x3d, 0x3c, 0xac, 0x80, 0xb9, 0xbd, 0x27, 0x17, 0x8e, 0x9f, 0x3d, 0xed,
	0xe7, 0x24, 0x30, 0x59, 0x05, 0x55, 0x56, 0xc1, 0x25, 0x5f, 0x3b, 0x6d, 0x23, 0x38, 0x72, 0xdb,
	0xea, 0x33, 0xe9, 0x41, 0xeb, 0x5e, 0xab, 0xcd, 0x37, 0x09, 0xa0, 0xb9, 0xa2, 0xeb, 0x54, 0xd0,
	0xe4, 0xaf, 0x1d, 0x2a, 0xd2, 0xe0, 0xeb, 0xde, 0x76, 0x87, 0x10, 0x57, 0xe9, 0x9a, 0x3c, 0x01,
	0x88, 0x45, 0x96, 0x51, 0x9e, 0x94, 0xb1, 0x9a, 0x1e, 0x6d, 0x7b, 0x33, 0x4b, 0xc8, 0x5b, 0xf8,
	0x2f, 0x4e, 0x59, 0xb9, 0x11, 0x34, 0x56, 0x4c, 0x70, 0xdb, 0xca, 0x77, 0xc3, 0x7d, 0xaf, 0x09,
	0x97, 0x1a, 0x0f, 0xbb, 0xb1, 0xf3, 0x45, 0xde, 0x40, 0x57, 0xb2, 0x04, 0x23, 0x5c, 0x2c, 0x30,
	0x56, 0xd2, 0xaf, 0xf7, 0xeb, 0xc3, 0xce, 0xf8, 0xd4, 0x55, 0xcf, 0x59, 0x82, 0x57, 0x1a, 0x0e,
	0x3b, 0x72, 0x73, 0x96, 0xe4, 0x15, 0x34, 0xcc, 0xd4, 0xfc, 0x7d, 0x2d, 0x7a, 0xf8, 0x75, 0x96,
	0xb3, 0x95, 0xf7, 0xc1, 0x4e, 0x79, 0xff, 0xf0, 0xee, 0xcd, 0x59, 0xe5, 0x48, 0xb3, 0x19, 0x27,
	0xef, 0x60, 0x9f, 0x71, 0xa6, 0x74, 0x16, 0x9d, 0xf1, 0xf3, 0x9d, 0xd6, 0xa8, 0xdc, 0xe1, 0x69,
	0x2d, 0xd4, 0x42, 0x32, 0x81, 0x03, 0x4d, 0xb4, 0x59, 0xbd, 0xd8, 0xa9, 0x82, 0x3e, 0x4f, 0x6b,
	0xa1, 0x91, 0x92, 0x11, 0x34, 0xed, 0x10, 0xec, 0x3a, 0x1f, 0x6f, 0x25, 0x6e, 0xa0, 0x69, 0x2d,
	0xac, 0x58, 0x93, 0x36, 0x34, 0x33, 0x94, 0x92, 0x2e, 0x71, 0xf0, 0xcd, 0x83, 0xff, 0x7f, 0x7f,
	0xd9, 0x75, 0xa1, 0x9d, 0xe5, 0xe5, 0xd4, 0xed, 0xdb, 0x76, 0x73, 0xa6, 0xf7, 0xa4, 0x74, 0xa6,
	0xa5, 0xa5, 0xb3, 0x05, 0x65, 0x69, 0x91, 0xa3, 0x7d, 0xdf, 0x96, 0xb3, 0x0f, 0x06, 0x2a, 0x9d,
	0x59, 0x96, 0xe3, 0x6c, 0xfc, 0x05, 0xba, 0x6e, 0x65, 0x92, 0x41, 0xe3, 0x96, 0xf2, 0x24, 0x45,
	0xb2, 0xe3, 0xaf, 0xd5, 0xce, 0xa8, 0x17, 0xfc, 0x03, 0xfd, 0xba, 0x50, 0x83, 0xda, 0xd0, 0xbb,
	0xf0, 0x26, 0xe7, 0x70, 0xca, 0x84, 0xab, 0xd4, 0xab, 0x11, 0x8b, 0xf4, 0xd3, 0xb1, 0xf3, 0x67,
	0x55, 0x5d, 0xde, 0x34, 0xf4, 0xe9, 0xf5, 0xcf, 0x00, 0x00, 0x00, 0xff, 0xff, 0x29, 0xfc, 0xf0,
	0xf2, 0x1e, 0x05, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// EventSourcedClient is the client API for EventSourced service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type EventSourcedClient interface {
	// The stream. One stream will be established per active entity.
	// Once established, the first message sent will be Init, which contains the entity ID, and,
	// if the entity has previously persisted a snapshot, it will contain that snapshot. It will
	// then send zero to many event messages, one for each event previously persisted. The entity
	// is expected to apply these to its state in a deterministic fashion. Once all the events
	// are sent, one to many commands are sent, with new commands being sent as new requests for
	// the entity come in. The entity is expected to reply to each command with exactly one reply
	// message. The entity should reply in order, and any events that the entity requests to be
	// persisted the entity should handle itself, applying them to its own state, as if they had
	// arrived as events when the event stream was being replayed on load.
	Handle(ctx context.Context, opts ...grpc.CallOption) (EventSourced_HandleClient, error)
}

type eventSourcedClient struct {
	cc *grpc.ClientConn
}

func NewEventSourcedClient(cc *grpc.ClientConn) EventSourcedClient {
	return &eventSourcedClient{cc}
}

func (c *eventSourcedClient) Handle(ctx context.Context, opts ...grpc.CallOption) (EventSourced_HandleClient, error) {
	stream, err := c.cc.NewStream(ctx, &_EventSourced_serviceDesc.Streams[0], "/cloudstate.eventsourced.EventSourced/handle", opts...)
	if err != nil {
		return nil, err
	}
	x := &eventSourcedHandleClient{stream}
	return x, nil
}

type EventSourced_HandleClient interface {
	Send(*EventSourcedStreamIn) error
	Recv() (*EventSourcedStreamOut, error)
	grpc.ClientStream
}

type eventSourcedHandleClient struct {
	grpc.ClientStream
}

func (x *eventSourcedHandleClient) Send(m *EventSourcedStreamIn) error {
	return x.ClientStream.SendMsg(m)
}

func (x *eventSourcedHandleClient) Recv() (*EventSourcedStreamOut, error) {
	m := new(EventSourcedStreamOut)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// EventSourcedServer is the server API for EventSourced service.
type EventSourcedServer interface {
	// The stream. One stream will be established per active entity.
	// Once established, the first message sent will be Init, which contains the entity ID, and,
	// if the entity has previously persisted a snapshot, it will contain that snapshot. It will
	// then send zero to many event messages, one for each event previously persisted. The entity
	// is expected to apply these to its state in a deterministic fashion. Once all the events
	// are sent, one to many commands are sent, with new commands being sent as new requests for
	// the entity come in. The entity is expected to reply to each command with exactly one reply
	// message. The entity should reply in order, and any events that the entity requests to be
	// persisted the entity should handle itself, applying them to its own state, as if they had
	// arrived as events when the event stream was being replayed on load.
	Handle(EventSourced_HandleServer) error
}

// UnimplementedEventSourcedServer can be embedded to have forward compatible implementations.
type UnimplementedEventSourcedServer struct {
}

func (*UnimplementedEventSourcedServer) Handle(srv EventSourced_HandleServer) error {
	return status.Errorf(codes.Unimplemented, "method Handle not implemented")
}

func RegisterEventSourcedServer(s *grpc.Server, srv EventSourcedServer) {
	s.RegisterService(&_EventSourced_serviceDesc, srv)
}

func _EventSourced_Handle_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(EventSourcedServer).Handle(&eventSourcedHandleServer{stream})
}

type EventSourced_HandleServer interface {
	Send(*EventSourcedStreamOut) error
	Recv() (*EventSourcedStreamIn, error)
	grpc.ServerStream
}

type eventSourcedHandleServer struct {
	grpc.ServerStream
}

func (x *eventSourcedHandleServer) Send(m *EventSourcedStreamOut) error {
	return x.ServerStream.SendMsg(m)
}

func (x *eventSourcedHandleServer) Recv() (*EventSourcedStreamIn, error) {
	m := new(EventSourcedStreamIn)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

var _EventSourced_serviceDesc = grpc.ServiceDesc{
	ServiceName: "cloudstate.eventsourced.EventSourced",
	HandlerType: (*EventSourcedServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "handle",
			Handler:       _EventSourced_Handle_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "cloudstate/event_sourced.proto",
}
